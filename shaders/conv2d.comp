// Prototype:
//  torch.nn.functional.conv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1)
//
// onnx:Conv
//  inputs: input, weight, bias(optional)
//  attributes:
//      strides: list of ints
//      pads: list of ints
//      dilations: list of ints
//      group: int
//      auto_pad: string, default ""
//  output: output
//  input shape: (N, C_in, H_in, W_in)  (NCHW)
//  weight shape: (C_out, C_in/groups, kH, kW)
//  bias shape: (C_out)
//  output shape: (N, C_out, H_out, W_out)
//      H_out = floor((H_in + 2*padding[0] - dilation[0]*(kH-1) - 1)/strides[0] + 1
//      W_out = floor((W_in + 2*padding[1] - dilation[1]*(kW-1) - 1)/strides[1] + 1

#version 440 core
#extension GL_AMD_gpu_shader_half_float: enable
// #define FLOAT4 f16vec4

#define FLOAT4 vec4

#include "activation.comp"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set=0, binding=0) writeonly uniform image2D uOutput;

layout(set=0, binding=1) uniform sampler2D uInput;

layout(set=0, binding=2) uniform sampler2D uKernel;

layout(set=0, binding=3) readonly buffer biasBuffer {
    float attr[]; // bias[C_out]
} uBias;

layout(push_constant) uniform constBuffer {
    ivec4 inputSize;     // W, H, C_in, N
    ivec4 outputSize;    // W, H, C_out, N
    ivec4 kernelSize;    // kW, kH, C_out, C_in
    ivec2 stride;        // strideW, strideH
    ivec2 padding;       // paddingW, paddingH
    ivec2 dilation;      // dilationW, dilationH
    int groups;
    int bias;
    int activation;
} uConstant;

#define UP_DIV(x, y) (((x) + (y) - 1) / (y))

// dispatch(UP_DIV(realW, 16), UP_DIV(realH, 16))
void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);

    int outW = uConstant.outputSize.x;
    int outH = uConstant.outputSize.y;
    int C_out = uConstant.outputSize.z;
    int N = uConstant.outputSize.w;
    int C4_out = (C_out + 3) / 4;

    int realWidth = outW * C4_out;
    int realHeight = outH * N;

    if (gid.x >= realWidth || gid.y >= realHeight) return;

    int C_in = uConstant.inputSize.z;
    int G = uConstant.groups;
    int C_out_per_group = C_out / G;
    int C_in_per_group = C_in / G;

    int out_w = gid.x % outW;
    int c4_out_idx = gid.x / outW;
    int out_h = gid.y % outH;
    int batch = gid.y / outH;

    int oc_start = c4_out_idx * 4;
    ivec4 oc_vec = ivec4(oc_start, oc_start + 1, oc_start + 2, oc_start + 3);

    // 检查是否越界
    bvec4 valid_oc = lessThan(oc_vec, ivec4(C_out));
    // if (!any(valid_oc)) return;

    // 检查 4 个 oc 是否属于同一个 group
    ivec4 g_vec = oc_vec / C_out_per_group;
    bool same_group = (g_vec.x == g_vec.y) && (g_vec.x == g_vec.z) && (g_vec.x == g_vec.w);

    FLOAT4 acc = FLOAT4(0.0);

    int K_W = uConstant.kernelSize.x;
    int K_H = uConstant.kernelSize.y;
    int H_in = uConstant.inputSize.y;
    int W_in = uConstant.inputSize.x;
    ivec2 s0 = ivec2(out_w, out_h) * uConstant.stride - uConstant.padding;

    if (same_group && all(valid_oc)) {
        // 4 个 oc 同组，可向量化
        int g = g_vec.x;
        int ic_start = g * C_in_per_group;
        int ic_end = ic_start + C_in_per_group;

        for (int ic = ic_start; ic < ic_end; ++ic) {
            int ic4 = ic / 4;
            int ic_comp = ic % 4;

            for (int ky = 0; ky < K_H; ++ky) {
                int iy = s0.y + ky * uConstant.dilation.y;
                if (iy < 0 || iy >= H_in) continue;

                for (int kx = 0; kx < K_W; ++kx) {
                    int ix = s0.x + kx * uConstant.dilation.x;
                    if (ix < 0 || ix >= W_in) continue;

                    // Read input (scalar per ic)
                    ivec2 inputCoord = ivec2(ix + ic4 * W_in, batch * H_in + iy);
                    float input_val = texelFetch(uInput, inputCoord, 0)[ic_comp];

                    // Read 4 weights at once: [w0, w1, w2, w3] for oc_vec
                    // weight layout: x = kx + ic4 * K_W, y = oc * K_H + ky
                    ivec2 kernelCoord0 = ivec2(kx + ic4 * K_W, oc_vec.x * K_H + ky);
                    ivec2 kernelCoord1 = ivec2(kx + ic4 * K_W, oc_vec.y * K_H + ky);
                    ivec2 kernelCoord2 = ivec2(kx + ic4 * K_W, oc_vec.z * K_H + ky);
                    ivec2 kernelCoord3 = ivec2(kx + ic4 * K_W, oc_vec.w * K_H + ky);

                    vec4 w0 = texelFetch(uKernel, kernelCoord0, 0);
                    vec4 w1 = texelFetch(uKernel, kernelCoord1, 0);
                    vec4 w2 = texelFetch(uKernel, kernelCoord2, 0);
                    vec4 w3 = texelFetch(uKernel, kernelCoord3, 0);

                    // Extract the ic_comp-th component from each
                    vec4 weights = vec4(
                        w0[ic_comp],
                        w1[ic_comp],
                        w2[ic_comp],
                        w3[ic_comp]
                    );

                    acc += input_val * weights;
                }
            }
        }
    } else {
        for (int comp = 0; comp < 4; ++comp) {
            if (!valid_oc[comp]) continue;

            int oc = oc_vec[comp];
            int g = oc / C_out_per_group;
            int ic_start = g * C_in_per_group;
            int ic_end = ic_start + C_in_per_group;

            float sum = 0.0;
            for (int ic = ic_start; ic < ic_end; ++ic) {
                int ic4 = ic / 4;
                int ic_comp = ic % 4;

                for (int ky = 0; ky < K_H; ++ky) {
                    int iy = s0.y + ky * uConstant.dilation.y;
                    // int iy = fma(ky, uConstant.dilation.y, s0.y);
                    if (iy < 0 || iy >= H_in) continue;

                    for (int kx = 0; kx < K_W; ++kx) {
                        int ix = s0.x + kx * uConstant.dilation.x;
                        // int ix = fma(kx, uConstant.dilation.x, s0.x);
                        if (ix < 0 || ix >= W_in) continue;

                        ivec2 inputCoord = ivec2(ix + ic4 * W_in, batch * H_in + iy);
                        float input_val = texelFetch(uInput, inputCoord, 0)[ic_comp];

                        int kernel_x = kx + (ic - ic_start) /4 * K_W;
                        int kernel_y = ky + oc * K_H;
                        float weight = texelFetch(uKernel, ivec2(kernel_x, kernel_y), 0)[(ic - ic_start) % 4];

                        sum += input_val * weight;
                    }
                }
            }
            acc[comp] = sum;
        }
    }

    // Add bias
    if (uConstant.bias == 1) {
        vec4 bias = vec4(0.0);
        for (int comp = 0; comp < 4; ++comp) {
            if (valid_oc[comp]) {
                bias[comp] = uBias.attr[oc_vec[comp]];
            }
        }
        acc += bias;
    }
    acc = activation(acc, uConstant.activation);

    imageStore(uOutput, gid, acc);
}