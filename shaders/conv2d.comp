// Prototype:
//  torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1,
//                  padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros',
//                  device=None, dtype=None)
// onnx:Conv
//  inputs: input, weight, bias(optional)
//  attributes:
//      strides: list of ints
//      pads: list of ints
//      dilations: list of ints
//      group: int
//      auto_pad: string, default ""
//  output: output
//  input shape: (N, C_in, H_in, W_in)  (NCHW)
//  weight shape: (C_out, C_in/groups, kH, kW)
//  bias shape: (C_out)
//  output shape: (N, C_out, H_out, W_out)
//      H_out = floor((H_in + 2*padding[0] - dilation[0]*(kH-1) - 1)/strides[0] + 1
//      W_out = floor((W_in + 2*padding[1] - dilation[1]*(kW-1) - 1)/strides[1] + 1
//  Note: currently only support padding_mode='zeros', groups=1, auto_pad=""
//        and dtype=float16
//  Note: currently only support stride=1, dilation=1 for auto_pad="SAME"
#version 440 core
#extension GL_AMD_gpu_shader_half_float: enable
#define FLOAT4 f16vec4


layout(set=0, binding=0) writeonly uniform image2D uOutput;
layout(set=0, binding=1) uniform sampler2D uInput;

layout(set=0, binding=2) uniform sampler2D uKernel;

layout(set=0, binding=3) uniform sampler1D uBias;

layout(set=0, binding=4) readonly uniform constBuffer {
    ivec4 inputSize;
    ivec4 outputSize;

    int in_channels;
    int out_channels;
    ivec2 kernelSize;
    ivec2 stride;
    ivec2 padding;
    ivec2 dilate;

    int groups;
    // bool bias;
    int padding_mode;
//    ivec4 offset;  //batchOffset, hOffset, outputHeight, other
} uConstant;


#define UP_DIV(x, y) (((x)+(y)-1)/(y))

layout (local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

void main()
{
    ivec3 pos = ivec3(gl_GlobalInvocationID);
    ivec3 outputSize = uConstant.outputSize.xyz;
    int oz = pos.z % uConstant.outputSize.z;
    int ob = pos.z / uConstant.outputSize.z;

    if (all(lessThan(pos.xy, outputSize.xy)))
    {
        ivec3 inputSize = uConstant.inputSize.xyz;
        ivec2 s0 = pos.xy*uConstant.stride-uConstant.padding;
        ivec2 sta = max(ivec2(0, 0), (UP_DIV(-s0, uConstant.dilate)));
        ivec2 end = min(uConstant.kernelSize, UP_DIV(uConstant.inputSize.xy - s0, uConstant.dilate));
        int fx, fy, fz;
        FLOAT4 color = FLOAT4(texelFetch(uBias, oz, 0));
        for (fy=sta.y; fy<end.y; ++fy)
        {
            int sy = fy*uConstant.dilate.y + s0.y;
            for (fx=sta.x; fx<end.x; ++fx)
            {
                int sx = fx*uConstant.dilate.x + s0.x;
                FLOAT4 inputValue = FLOAT4(texelFetch(uInput, ivec2(sx+oz*uConstant.inputSize.x, sy+ob*uConstant.inputSize.y), 0));

                FLOAT4 k = FLOAT4(texelFetch(uKernel, ivec2(fx+fy*uConstant.kernelSize.x, oz), 0));

                color  += k*inputValue;
            }
        }


        color = FLOAT4(max(color, FLOAT4(0)));
        color = FLOAT4(clamp(color, FLOAT4(0), FLOAT4(6)));
        imageStore(uOutput, ivec2(pos.x+oz*uConstant.outputSize.x, pos.y+ob*uConstant.outputSize.y), color);
    }

}
