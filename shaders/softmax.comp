#version 450 core
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

#ifdef FP16
#extension GL_AMD_gpu_shader_half_float: enable
#extension GL_EXT_shader_16bit_storage : enable
#define FLOAT float16_t
#define FLOAT4 f16vec4
#define FLOAT2 f16vec2
#else
#define FLOAT float
#define FLOAT4 vec4
#define FLOAT2 vec2
#endif

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0) writeonly uniform image2DArray OutputImage;
layout(binding = 1) uniform sampler2DArray InputImage;

layout(push_constant) uniform constBuffer {
    ivec4 outShape;    // [N, C, H, W]
    int axis;
    int fp16;
} uConst;

// Axis 0: softmax over N (batch)
void softmax_axis0() {
    uint x = gl_GlobalInvocationID.x;  // w
    uint y = gl_GlobalInvocationID.y;  // h
    uint z = gl_GlobalInvocationID.z;  // layer index (c_base / 4)
    int N = uConst.outShape.x;
    int C = uConst.outShape.y;
    int H = uConst.outShape.z;
    int W = uConst.outShape.w;
    int C4 = (C + 3) / 4;

    if (x >= W || y >= H || z >= C4) return;

    uint h = y;
    uint c_base = z * 4;

    // Initialize max value and sum of exp values
    FLOAT4 max_val = FLOAT4(-1e9);
    FLOAT4 sum_exp = FLOAT4(0.0);

    // Step 1: Find the maximum value over height (h)
    for (uint n = 0; n < N; ++n) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(x, n * H + h, z), 0));
        max_val = max(max_val, v);
    }

    // Step 2: Compute the sum of exp(values - max_val)
    for (uint n = 0; n < N; ++n) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(x, n * H + y, z), 0));
        FLOAT4 exp_v = exp(v - max_val);
        sum_exp += exp_v;
    }

    // Step 3: Normalize and store the result back to the output image
    for (uint n = 0; n < N; ++n) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(x, n * H + y, z), 0));
        FLOAT4 softmax_v = exp(v - max_val) / sum_exp;
        imageStore(OutputImage, ivec3(x, n * H + y, z), softmax_v);
    }
}

// Axis 1: softmax over C (channel) â† MOST COMMON
void softmax_axis1() {
    uint w = gl_GlobalInvocationID.x;  // w
    uint h = gl_GlobalInvocationID.y;  // h
    uint n = gl_GlobalInvocationID.z;  // n
    int N = uConst.outShape.x;
    int C = uConst.outShape.y;
    int H = uConst.outShape.z;
    int W = uConst.outShape.w;
    int C4 = (C + 3) / 4;

    if (w >= W || h >= H || n >= N) return;

     uint y = n * H + h;

    // Initialize max value and sum of exp values
    FLOAT max_val = FLOAT(-1e9);
    FLOAT sum_exp = FLOAT(0.0);

     for (int z = 0; z < C4; ++z) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(w, y, z), 0));
        for (int comp = 0; comp < 4; ++comp) {
            uint c = z * 4 + comp;
            if (c < C) {
                max_val = FLOAT(max(max_val, v[comp]));
            }
        }
    }

    // Step 2: Compute the sum of exp(values - max_val)
    for (int z = 0; z < C4; ++z) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(w, y, z), 0));
        for (int comp = 0; comp < 4; ++comp) {
            uint c = z * 4 + comp;
            if (c < C) {
                sum_exp += exp(v[comp] - max_val);
            }
        }
    }

    // Step 3: Normalize and store the result back to the output image
    for (int z = 0; z < C4; ++z) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(w, y, z), 0));
        FLOAT4 out_v = FLOAT4(0.0);
        for (int comp = 0; comp < 4; ++comp) {
            uint c = z * 4 + comp;
            if (c < C) {
                out_v[comp] = exp(v[comp] - max_val) / sum_exp;
            }
        }
        imageStore(OutputImage, ivec3(w, y, z), out_v);
    }
}


// Axis 2: softmax over H (height)
void softmax_axis2() {
    uint x = gl_GlobalInvocationID.x;  // w
    uint y = gl_GlobalInvocationID.y;  // n
    uint z = gl_GlobalInvocationID.z;  // layer index (c_base / 4)
    int N = uConst.outShape.x;
    int C = uConst.outShape.y;
    int H = uConst.outShape.z;
    int W = uConst.outShape.w;
    int C4 = (C + 3) / 4;

    if (x >= W || y >= N || z >= C4) return;

    uint n = y;
    uint c_base = z * 4;

    // Initialize max value and sum of exp values
    FLOAT4 max_val = FLOAT4(-1e9);
    FLOAT4 sum_exp = FLOAT4(0.0);

    // Step 1: Find the maximum value over height (h)
    for (uint h = 0; h < H; ++h) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(x, n * H + h, z), 0));
        max_val = max(max_val, v);
    }

    // Step 2: Compute the sum of exp(values - max_val)
    for (uint h = 0; h < H; ++h) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(x, n * H + h, z), 0));
        FLOAT4 exp_v = exp(v - max_val);
        sum_exp += exp_v;
    }

    // Step 3: Normalize and store the result back to the output image
    for (uint h = 0; h < H; ++h) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(x, n * H + h, z), 0));
        FLOAT4 softmax_v = exp(v - max_val) / sum_exp;
        imageStore(OutputImage, ivec3(x, n * H + h, z), softmax_v);
    }
}

// Axis 3: softmax over W (width)
void softmax_axis3() {
    uint x = gl_GlobalInvocationID.x;  // h
    uint y = gl_GlobalInvocationID.y;  // n
    uint z = gl_GlobalInvocationID.z;  // layer index (c_base / 4)
    int N = uConst.outShape.x;
    int C = uConst.outShape.y;
    int H = uConst.outShape.z;
    int W = uConst.outShape.w;
    int C4 = (C + 3) / 4;

    if (x >= H || y >= N || z >= C4) return;

    uint n = y;
    uint h = x;
    uint c_base = z * 4;

    // Initialize max value and sum of exp values
    FLOAT4 max_val = FLOAT4(-1e9);
    FLOAT4 sum_exp = FLOAT4(0.0);

    // Step 1: Find the maximum value over height (h)
    for (uint w = 0; w < W; ++w) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(w, n * H + h, z), 0));
        max_val = FLOAT4(max(max_val, v));
    }

    // Step 2: Compute the sum of exp(values - max_val)
    for (uint w = 0; w < W; ++w) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(w, n * H + h, z), 0));
        FLOAT4 exp_v = exp(v - max_val);
        sum_exp += exp_v;
    }

    // Step 3: Normalize and store the result back to the output image
    for (uint w = 0; w < W; ++w) {
        FLOAT4 v = FLOAT4(texelFetch(InputImage, ivec3(w, n * H + h, z), 0));
        FLOAT4 softmax_v = exp(v - max_val) / sum_exp;
        imageStore(OutputImage, ivec3(w, n * H + h, z), softmax_v);
    }
}

// Dispatch rules (CPU side):
// axis=0 (N): dispatch(W, H*C4)
// axis=1 (C): dispatch(W, N*H)
// axis=2 (H): dispatch(W, N*C4)
// axis=3 (W): dispatch(H, N*C4)

void main() {
    if (uConst.axis == 0) softmax_axis0();
    else if (uConst.axis == 1) softmax_axis1();
    else if (uConst.axis == 2) softmax_axis2();
    else if (uConst.axis == 3) softmax_axis3();
}