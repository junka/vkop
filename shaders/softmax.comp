#version 450 core
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0) writeonly uniform image2DArray OutputImage;
layout(binding = 1) uniform sampler2DArray InputImage;

layout(push_constant) uniform constBuffer {
    ivec4 outImgSize;  // [W, N*H, C4, _]
    ivec4 outShape;    // [N, C, H, W]  â† NCHW
    int axis;
} uConst;

shared vec4 sharedMax[256];
shared vec4 sharedSum[256];

// Helper: reduce vec4 to scalar
float reduceMax(vec4 v) { return max(max(v.x, v.y), max(v.z, v.w)); }
float reduceSum(vec4 v) { return v.x + v.y + v.z + v.w; }

// Axis 0: softmax over N (batch)
void softmax_axis0() {
    uint lid = gl_LocalInvocationIndex;
    int N = uConst.outShape.x;
    int C = uConst.outShape.y;
    int H = uConst.outShape.z;
    int W = uConst.outShape.w;
    int C4 = (C + 3) / 4;

    // Each workgroup handles: (c_group, h, w)
    int w = int(gl_WorkGroupID.x);
    int idx = int(gl_WorkGroupID.y); // = h * C4 + c_group
    if (w >= W || idx >= H * C4) return;

    int h = idx / C4;
    int c_group = idx % C4;

    vec4 threadMax = vec4(-1e38f);
    for (int n = int(lid); n < N; n += 256) {
        int y = n * H + h;
        vec4 v = texelFetch(InputImage, ivec3(w, y, c_group), 0);
        threadMax = max(threadMax, v);
    }
    sharedMax[lid] = threadMax;
    barrier();

    for (int s = 128; s > 0; s >>= 1) {
        if (lid < s) sharedMax[lid] = max(sharedMax[lid], sharedMax[lid + s]);
        barrier();
    }
    vec4 max_val = sharedMax[0];

    vec4 threadSum = vec4(0.0f);
    for (int n = int(lid); n < N; n += 256) {
        int y = n * H + h;
        vec4 v = texelFetch(InputImage, ivec3(w, y, c_group), 0);
        threadSum += exp(v - max_val);
    }
    sharedSum[lid] = threadSum;
    barrier();

    for (int s = 128; s > 0; s >>= 1) {
        if (lid < s) sharedSum[lid] += sharedSum[lid + s];
        barrier();
    }
    vec4 sum_exp = sharedSum[0];

    for (int n = int(lid); n < N; n += 256) {
        int y = n * H + h;
        vec4 v = texelFetch(InputImage, ivec3(w, y, c_group), 0);
        vec4 outval = exp(v - max_val) / sum_exp;
        imageStore(OutputImage, ivec3(w, y, c_group), outval);
    }
}

// Axis 1: softmax over C (channel) â† MOST COMMON
void softmax_axis1() {
    uint lid = gl_LocalInvocationIndex;
    int N = uConst.outShape.x;
    int C = uConst.outShape.y;
    int H = uConst.outShape.z;
    int W = uConst.outShape.w;
    int C4 = (C + 3) / 4;

    // Each workgroup handles: (n, h, w)
    int w = int(gl_WorkGroupID.x);
    int idx = int(gl_WorkGroupID.y); // = n * H + h
    if (w >= W || idx >= N * H) return;

    int n = idx / H;
    int h = idx % H;

    float threadMax = -1e38f;
    for (int c_group = int(lid); c_group < C4; c_group += 256) {
        vec4 v = texelFetch(InputImage, ivec3(w, n * H + h, c_group), 0);
        threadMax = max(threadMax, reduceMax(v));
    }
    sharedMax[lid].x = threadMax;
    barrier();

    for (int s = 128; s > 0; s >>= 1) {
        if (lid < s) sharedMax[lid].x = max(sharedMax[lid].x, sharedMax[lid + s].x);
        barrier();
    }
    float max_val = sharedMax[0].x;

    float threadSum = 0.0f;
    for (int c_group = int(lid); c_group < C4; c_group += 256) {
        vec4 v = texelFetch(InputImage, ivec3(w, n * H + h, c_group), 0);
        vec4 exp_v = exp(v - vec4(max_val));
        // Mask padding channels in last group
        if (c_group == C4 - 1 && C % 4 != 0) {
            int rem = C % 4;
            bvec4 mask = lessThan(ivec4(0,1,2,3), ivec4(rem));
            exp_v *= vec4(mask);
        }
        threadSum += reduceSum(exp_v);
    }
    sharedSum[lid].x = threadSum;
    barrier();

    for (int s = 128; s > 0; s >>= 1) {
        if (lid < s) sharedSum[lid].x += sharedSum[lid + s].x;
        barrier();
    }
    float sum_exp = sharedSum[0].x;

    for (int c_group = int(lid); c_group < C4; c_group += 256) {
        int y = n * H + h;
        vec4 v = texelFetch(InputImage, ivec3(w, y, c_group), 0);
        vec4 outval = exp(v - vec4(max_val)) / vec4(sum_exp);
        if (c_group == C4 - 1 && C % 4 != 0) {
            int rem = C % 4;
            bvec4 mask = lessThan(ivec4(0,1,2,3), ivec4(rem));
            outval *= vec4(mask);
        }
        imageStore(OutputImage, ivec3(w, y, c_group), outval);
    }
}

// Axis 2: softmax over H (height)
void softmax_axis2() {
    uint lid = gl_LocalInvocationIndex;
    int N = uConst.outShape.x;
    int C = uConst.outShape.y;
    int H = uConst.outShape.z;
    int W = uConst.outShape.w;
    int C4 = (C + 3) / 4;

    // Each workgroup handles: (n, c_group, w)
    int w = int(gl_WorkGroupID.x);
    int idx = int(gl_WorkGroupID.y); // = n * C4 + c_group
    if (w >= W || idx >= N * C4) return;

    int n = idx / C4;
    int c_group = idx % C4;

    vec4 threadMax = vec4(-1e38f);
    for (int h = int(lid); h < H; h += 256) {
        int y = n * H + h;
        vec4 v = texelFetch(InputImage, ivec3(w, y, c_group), 0);
        threadMax = max(threadMax, v);
    }
    sharedMax[lid] = threadMax;
    barrier();

    for (int s = 128; s > 0; s >>= 1) {
        if (lid < s) sharedMax[lid] = max(sharedMax[lid], sharedMax[lid + s]);
        barrier();
    }
    vec4 max_val = sharedMax[0];

    vec4 threadSum = vec4(0.0f);
    for (int h = int(lid); h < H; h += 256) {
        int y = n * H + h;
        vec4 v = texelFetch(InputImage, ivec3(w, y, c_group), 0);
        threadSum += exp(v - max_val);
    }
    sharedSum[lid] = threadSum;
    barrier();

    for (int s = 128; s > 0; s >>= 1) {
        if (lid < s) sharedSum[lid] += sharedSum[lid + s];
        barrier();
    }
    vec4 sum_exp = sharedSum[0];

    for (int h = int(lid); h < H; h += 256) {
        int y = n * H + h;
        vec4 v = texelFetch(InputImage, ivec3(w, y, c_group), 0);
        vec4 outval = exp(v - max_val) / sum_exp;
        imageStore(OutputImage, ivec3(w, y, c_group), outval);
    }
}

// Axis 3: softmax over W (width)
void softmax_axis3() {
    uint lid = gl_LocalInvocationIndex;
    int N = uConst.outShape.x;
    int C = uConst.outShape.y;
    int H = uConst.outShape.z;
    int W = uConst.outShape.w;
    int C4 = (C + 3) / 4;

    // Each workgroup handles: (n, c_group, h)
    int h = int(gl_WorkGroupID.x);
    int idx = int(gl_WorkGroupID.y); // = n * C4 + c_group
    if (h >= H || idx >= N * C4) return;

    int n = idx / C4;
    int c_group = idx % C4;

    vec4 threadMax = vec4(-1e38f);
    for (int w = int(lid); w < W; w += 256) {
        int y = n * H + h;
        vec4 v = texelFetch(InputImage, ivec3(w, y, c_group), 0);
        threadMax = max(threadMax, v);
    }
    sharedMax[lid] = threadMax;
    barrier();

    for (int s = 128; s > 0; s >>= 1) {
        if (lid < s) sharedMax[lid] = max(sharedMax[lid], sharedMax[lid + s]);
        barrier();
    }
    vec4 max_val = sharedMax[0];

    vec4 threadSum = vec4(0.0f);
    for (int w = int(lid); w < W; w += 256) {
        int y = n * H + h;
        vec4 v = texelFetch(InputImage, ivec3(w, y, c_group), 0);
        threadSum += exp(v - max_val);
    }
    sharedSum[lid] = threadSum;
    barrier();

    for (int s = 128; s > 0; s >>= 1) {
        if (lid < s) sharedSum[lid] += sharedSum[lid + s];
        barrier();
    }
    vec4 sum_exp = sharedSum[0];

    for (int w = int(lid); w < W; w += 256) {
        int y = n * H + h;
        vec4 v = texelFetch(InputImage, ivec3(w, y, c_group), 0);
        vec4 outval = exp(v - max_val) / sum_exp;
        imageStore(OutputImage, ivec3(w, y, c_group), outval);
    }
}

// Dispatch rules (CPU side):
// axis=0 (N): dispatch(W, H*C4)
// axis=1 (C): dispatch(W, N*H)
// axis=2 (H): dispatch(W, N*C4)
// axis=3 (W): dispatch(H, N*C4)

void main() {
    if (uConst.axis == 0) softmax_axis0();
    else if (uConst.axis == 1) softmax_axis1();
    else if (uConst.axis == 2) softmax_axis2();
    else if (uConst.axis == 3) softmax_axis3();
}