#version 450 core

#define FLOAT4 vec4
#define FLOAT float

#include "activation.comp"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set=0, binding = 0) writeonly uniform image2DArray outputImage; // [W, N*H, C4]
layout(set=0, binding = 1) uniform sampler2DArray inputImage;          // [W, N*H, C4]

// length = C (number of channels)
// Each vec4 follows as scale..., bias..., mean..., variance...
layout(set=0, binding = 2) uniform textureBuffer uMeanVarScaleBias;
// {
//     mat4 attr[];
// } uMeanVarScaleBias;

layout(push_constant) uniform batchNormBuffer {
    ivec4 outShape; // [N, C, H, W]
    float eps;
    int activation;
} uBatchNormParam;

void main() {
    ivec3 gid3 = ivec3(gl_GlobalInvocationID);
    int W = uBatchNormParam.outShape.w;
    int H = uBatchNormParam.outShape.z;
    int C = uBatchNormParam.outShape.y;
    int N = uBatchNormParam.outShape.x;
    int C4 = (C + 3) / 4;

    int w = gid3.x;
    int nh = gid3.y; // = n * H + h
    int c4 = gid3.z;

    // Bounds check
    if (w >= W || nh >= N * H || c4 >= C4) {
        return;
    }

    // Decode batch and height
    int n = nh / H;
    int h = nh % H;

    // Fetch input pixel (RGBA = 4 channels)
    vec4 inputPixel = texelFetch(inputImage, gid3, 0);

    // Load per-channel parameters, padding done in previous step
    // vec4 scale4 = uMeanVarScaleBias.attr[c4][0];
    // vec4 bias4 = uMeanVarScaleBias.attr[c4][1];
    // vec4 mean4 = uMeanVarScaleBias.attr[c4][2];
    // vec4 var4 = uMeanVarScaleBias.attr[c4][3];
    vec4 scale4 = texelFetch(uMeanVarScaleBias, c4 * 4);
    vec4 bias4 = texelFetch(uMeanVarScaleBias, c4 * 4 + 1);
    vec4 mean4 = texelFetch(uMeanVarScaleBias, c4 * 4 + 2);
    vec4 var4 = texelFetch(uMeanVarScaleBias, c4 * 4 + 3);

    // BatchNorm formula: y = scale * (x - mean) / sqrt(var + eps) + bias
    vec4 inv_std = inversesqrt(var4 + vec4(uBatchNormParam.eps));
    vec4 normalized = (inputPixel - mean4) * inv_std;
    vec4 pixel = scale4 * normalized + bias4;

    for (int i = 0; i < 4; i++) {
        if (c4 * 4 + i >= C)
            pixel[i] = 0.0;
    }
    pixel = activation(pixel, uBatchNormParam.activation);
    // Store result
    imageStore(outputImage, gid3, pixel);
}