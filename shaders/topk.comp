#version 450 core
#extension GL_EXT_subgroup_uniform_control_flow: require

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(set=0, binding = 0) buffer indiceBuffer {
    uint data[];
} uIndice;
layout(set=0, binding = 1) buffer valueBuffer {
    float data[];
} uValue;
layout(set=0, binding = 2) readonly buffer indexBuffer {
    uint data[];
} uIndex;
layout(set=0, binding = 3) readonly buffer inputBuffer {
    float data[];
} uInput;

layout(push_constant) uniform parameter {
    ivec4 inShape;
    int k;
    int axis;
    int largest;
    int sorted;
} uParam;

shared float sharedData[256];
shared uint sharedIndices[256];

#define SWAP_FLOAT(a, b)  { float _t = (a); (a) = (b); (b) = _t;}
#define SWAP_UINT(a, b)  { uint _t = (a); (a) = (b); (b) = _t; }

void bitonicSort(int count) {
    int powerOfTwo = 1;
    while (powerOfTwo < count && powerOfTwo < 256) {
        powerOfTwo <<= 1;
    }
    uint lid = gl_LocalInvocationID.x;

    for (int size = 2; size <= powerOfTwo; size <<= 1) {
        for (int stride = size >> 1; stride > 0; stride >>= 1) {
            if (int(lid) < powerOfTwo) {
                uint pos = lid ^ uint(stride);
                if (pos > lid) {
                    bool direction = (lid & uint(size)) == 0u;
                    if (uParam.largest != 0) {
                        direction = !direction;
                    }
                    bool shouldSwap = false;
                    if (direction) {
                        shouldSwap = sharedData[lid] > sharedData[pos];
                    } else {
                        shouldSwap = sharedData[lid] < sharedData[pos];
                    }

                    if (shouldSwap) {
                        SWAP_FLOAT(sharedData[lid], sharedData[pos]);
                        SWAP_UINT(sharedIndices[lid], sharedIndices[pos]);
                    }
                }
            }
            barrier();
        }
    }
}

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    int lid = int(gl_LocalInvocationID.x);

    if (uParam.axis == 1 && y >= uParam.inShape.x) {
        return;
    }

    if (uParam.axis == 0) {
        int N = uParam.inShape.x;
        uint group_id = gl_WorkGroupID.x;
        uint start = group_id * 256u;
        int localCount = min(int(N - start), 256);

        if (x < N) {
            sharedData[lid] = uInput.data[x];
            sharedIndices[lid] = uIndex.data[x];
        } else {
            sharedData[lid] = ((uParam.largest != 0) ? -3.4e38 : 3.4e38);
            sharedIndices[lid] = -1;
        }
        barrier();

        bitonicSort(localCount);

        if (lid < uParam.k && lid < localCount) {
            uint outOffset = group_id * uParam.k;
            uValue.data[outOffset + lid] = sharedData[lid];
            uIndice.data[outOffset + lid] = sharedIndices[lid];
        }
    } else if (uParam.axis == 1) {
        int rows = uParam.inShape.x;
        int cols = uParam.inShape.y;

        uint group_id = gl_WorkGroupID.x;
        uint start = group_id * 256u;
        int localCount = min(int(cols - start), 256);

        if (x < cols) {
            sharedData[lid] = uInput.data[y * cols + x];
            sharedIndices[lid] = uIndex.data[y * cols + x];
        } else {
            sharedData[lid] = ((uParam.largest != 0) ? -3.4e38 : 3.4e38);
            sharedIndices[lid] = -1;
        }
        barrier();

        bitonicSort(localCount);

        uint num_wgx = (cols + 255)/256;
        if (lid < uParam.k && lid < localCount) {
            uint outOffset = (y * num_wgx + group_id) * uParam.k;
            uValue.data[outOffset + lid] = sharedData[lid];
            uIndice.data[outOffset + lid] = sharedIndices[lid];
        }
    }
}