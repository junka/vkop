#version 450 core

#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

layout(set=0, binding=0) writeonly uniform image2DArray uOutput; // [W_out, N*H_out, C4]
layout(set=0, binding=1) uniform sampler2DArray uInput;          // [W_in, N*H_in, C4]
layout(set=0, binding=2) uniform sampler2DArray uGrid;           // [2, W_out*N, UP_DIV(H_out, 4)]

layout(push_constant) uniform gridSampleBuffer {
    ivec4 outImgSize;   // [W_out, N*H_out, C4, _]
    ivec2 inShape;      // [W_in, H_in]
    ivec2 outShape;     // [W_out, H_out]
    int paddingMode;    // 0: zeros, 1: border, 2: reflection
    int interpolation_mode; // 0: bilinear, 1: nearest
    int alignCorners;
} uGridSampleParam;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

vec4 LoadSample(int px, int py, int c, int n, ivec2 inShape) {
    if (px < 0 || px >= inShape.x || py < 0 || py >= inShape.y) {
        if (uGridSampleParam.paddingMode == 0) { // zeros
            return vec4(0.0);
        } else if (uGridSampleParam.paddingMode == 1) { // border
            px = clamp(px, 0, inShape.x - 1);
            py = clamp(py, 0, inShape.y - 1);
        } else if (uGridSampleParam.paddingMode == 2) { // reflection
            px = int(mod(float(px), 2.0 * float(inShape.x)));
            if (px >= inShape.x) px = 2 * inShape.x - px - 1;
            py = int(mod(float(py), 2.0 * float(inShape.y)));
            if (py >= inShape.y) py = 2 * inShape.y - py - 1;

			px = clamp(px, 0, inShape.x - 1);
			py = clamp(py, 0, inShape.y - 1);
        }
    }
    return texelFetch(uInput, ivec3(px, n * inShape.y + py, c), 0);
}

void main() {
    ivec3 gid = ivec3(gl_GlobalInvocationID);

    int W_out = uGridSampleParam.outImgSize.x;
    int HN_out = uGridSampleParam.outImgSize.y; // = N * H_out
    int C4 = uGridSampleParam.outImgSize.z;

    int W_in = uGridSampleParam.inShape.x;
    int H_in = uGridSampleParam.inShape.y;
    int H_out = uGridSampleParam.outShape.y; // single batch height

    if (gid.x >= W_out || gid.y >= HN_out || gid.z >= C4) {
        return;
    }

    // Decode batch and spatial position
    int n = gid.y / H_out;
    int h = gid.y % H_out;
    int w = gid.x;
    int c4 = gid.z;

    // Fetch grid value for this (n, h, w)
	// [N, H_out, W_out, 2] 存储为
	// Width = 2, Height = W_out * N 的 UP_DIV(Hout, 4) 的array layers
	// 原始的nchw 获取的对应的grid 中的坐标是 [n, h, w], 也就是说 n h w 2,
	// 对应到pack之后的格式中的坐标是第 h4 个 layer中的， w idx 为 0 或 1，h idx 为 w * N + n 或者 n * Wout + w
    // 获取 grid 中的坐标 (注意: x_index 对应 width, 也就是 0 或 1)
    int layer = h / 4; // 每个 layer 对应 4 行
    int remainder = h % 4;
    int y_index = w + n * W_out;

    // 根据 remainder 选择正确的值
    float gridX = texelFetch(uGrid, ivec3(0, y_index, layer), 0)[remainder];
    float gridY = texelFetch(uGrid, ivec3(1, y_index, layer), 0)[remainder];

    // Map normalized grid [-1, 1] to input pixel coordinates
    float a = float(uGridSampleParam.alignCorners);
	float b = 1.0f - a;
    float inputX = ((gridX + 1.0) * (W_in - a) - b) * 0.5;
    float inputY = ((gridY + 1.0) * (H_in - a) - b) * 0.5;

    if (uGridSampleParam.interpolation_mode == 0) { // bilinear
        int x0 = int(floor(inputX));
        int y0 = int(floor(inputY));
        int x1 = x0 + 1;
        int y1 = y0 + 1;

        vec4 i00 = LoadSample(x0, y0, c4, n, ivec2(W_in, H_in));
        vec4 i01 = LoadSample(x1, y0, c4, n, ivec2(W_in, H_in));
        vec4 i10 = LoadSample(x0, y1, c4, n, ivec2(W_in, H_in));
        vec4 i11 = LoadSample(x1, y1, c4, n, ivec2(W_in, H_in));

        float fx = inputX - float(x0);
        float fy = inputY - float(y0);

        vec4 top = mix(i00, i01, fx);
        vec4 bot = mix(i10, i11, fx);
        vec4 result = mix(top, bot, fy);

        imageStore(uOutput, gid, result);
    } else { // nearest
        int nx = int(round(inputX));
        int ny = int(round(inputY));
        vec4 result = LoadSample(nx, ny, c4, n, ivec2(W_in, H_in));
        imageStore(uOutput, gid, result);
    }
}