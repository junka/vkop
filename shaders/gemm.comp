#version 450

layout(local_size_x = 16, local_size_y = 16) in;

// Matrix multiplication
// A' = transpose(A) if transA else A
// B' = transpose(B) if transB else B
// Compute Y = alpha * A' * B' + beta * C,

// layout(set=0, binding = 0) writeonly uniform imageBuffer bufferY;
layout(set=0, binding = 0) writeonly buffer BufferY {
    uint data[];
} bufferY;

layout(set=0, binding = 1) readonly buffer BufferA {
    uint data[];
} bufferA;

layout(set=0, binding = 2) readonly buffer BufferB {
    uint data[];
} bufferB;

layout(set=0, binding = 3) readonly buffer BufferC {
    uint data[];
} bufferC;

layout(push_constant) uniform paraBuffer {
    int M; // 行数
    int N; // 列数
    int K; // 共同维度
    int has_bias;
    int transA;
    int transB;
    float alpha;
    float beta;
    int fp16a;
    int fp16b;
    int fp16c;
} uParams;

void main() {
    int j = int(gl_GlobalInvocationID.x); // column index in Y
    int i = int(gl_GlobalInvocationID.y); // row index in Y

    if (i >= uParams.M || j >= uParams.N) return;

    float sum = 0.0;
    for (int k = 0; k < uParams.K; ++k) {
        // Load A[i][k] from bufferA, considering transA
        float a_val;
        int index;
        if (uParams.transA == 1) {
            // A is stored as K×M (row-major), so A^T[i][k] = A_physical[k][i]
            index = k * uParams.M + i;
        } else {
            // A is stored as M×K, A[i][k] = A_physical[i][k]
            index = i * uParams.K + k;
        }
        if (uParams.fp16a == 1) {
            a_val = unpackHalf2x16(bufferA.data[index/2])[index%2];
        } else {
            a_val = uintBitsToFloat(bufferA.data[index]);
        }

        // Load B[k][j] from bufferB, considering transB
        float b_val;
        if (uParams.transB == 1) {
            // B is stored as N×K (row-major), so B^T[k][j] = B_physical[j][k]
            index = j * uParams.K + k;
        } else {
            // B is stored as K×N, B[k][j] = B_physical[k][j]
            index = k * uParams.N + j;
        }
        if (uParams.fp16b == 1) {
            b_val = unpackHalf2x16(bufferB.data[index/2])[index%2];
        } else {
            b_val = uintBitsToFloat(bufferB.data[index]);
        }
        sum += a_val * b_val;
    }

    int yIndex = i * uParams.N + j;       // C[i][j] in row-major
    sum *= uParams.alpha;
    float c_val;
    if (uParams.has_bias == 1) {
        if (uParams.fp16c == 1) {
            c_val = unpackHalf2x16(bufferC.data[yIndex/2])[yIndex%2];
        } else {
            c_val = uintBitsToFloat(bufferC.data[yIndex]);
        }
        sum += c_val * uParams.beta;
    }

    // if (uParams.fp16 == 1) {
    //     vec2 y_val = unpackHalf2x16(bufferY.data[yIndex/2]);
    //     y_val[yIndex%2] = sum;
    //     bufferY.data[yIndex/2] = packHalf2x16(y_val);
    // } else {
    //     bufferY.data[yIndex] = floatBitsToUint(sum);
    // }
    bufferY.data[yIndex] = floatBitsToUint(sum);
    // bufferY.data[yIndex] = bufferA.data[yIndex];
    // vec4 sum4 = imageLoad(bufferY, yIndex/4);
    // vec4 sum4 = vec4(0);
    // texelFetch(bufferY, yIndex/4);
    // sum4[yIndex%4] = sum;
    // imageStore(bufferY, yIndex, sum4);
}