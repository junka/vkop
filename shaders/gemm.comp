#version 450

layout(local_size_x = 16, local_size_y = 16) in;

// Matrix multiplication
// A' = transpose(A) if transA else A
// B' = transpose(B) if transB else B
// Compute Y = alpha * A' * B' + beta * C,

layout(set=0, binding = 0) writeonly buffer BufferY {
    float data[];
} bufferY;

layout(set=0, binding = 1) readonly buffer BufferA {
    float data[];
} bufferA;

layout(set=0, binding = 2) readonly buffer BufferB {
    float data[];
} bufferB;

layout(set=0, binding = 3) readonly buffer BufferC {
    float data[];
} bufferC;

layout(push_constant) readonly uniform paraBuffer {
    int M; // 行数
    int N; // 列数
    int K; // 共同维度
    int has_bias;
    int transA;
    int transB;
    float alpha;
    float beta;
} uParams;

void main() {
    uint j = gl_GlobalInvocationID.x; // column index in Y
    uint i = gl_GlobalInvocationID.y; // row index in Y

    if (i >= uParams.M || j >= uParams.N) return;

    float sum = 0.0;
    for (int k = 0; k < uParams.K; ++k) {
        // Load A[i][k] from bufferA, considering transA
        float a_val;
        if (uParams.transA == 1) {
            // A is stored as K×M (row-major), so A^T[i][k] = A_physical[k][i]
            // index = k * M + i
            a_val = bufferA.data[k * uParams.M + i];
        } else {
            // A is stored as M×K, A[i][k] = A_physical[i][k]
            // index = i * K + k
            a_val = bufferA.data[i * uParams.K + k];
        }

        // Load B[k][j] from bufferB, considering transB
        float b_val;
        if (uParams.transB == 1) {
            // B is stored as N×K (row-major), so B^T[k][j] = B_physical[j][k]
            // index = j * K + k
            b_val = bufferB.data[j * uParams.K + k];
        } else {
            // B is stored as K×N, B[k][j] = B_physical[k][j]
            // index = k * N + j
            b_val = bufferB.data[k * uParams.N + j];
        }

        sum += a_val * b_val;
    }

    uint yIndex = i * uParams.N + j;       // C[i][j] in row-major
    sum *= uParams.alpha;
    if (uParams.has_bias == 1) {
        sum += bufferC.data[yIndex] * uParams.beta;
    }

    bufferY.data[yIndex] = sum;
}