#version 450 core

layout(set=0, binding=0) uniform sampler2DArray uInput;    // [OH*OW*N, 1, C4]
layout(set=0, binding=1) writeonly uniform image2DArray uOutput; // [W_out, N*H_out, C4]
layout(set=0, binding=2) uniform sampler2DArray uBias;     // [1, 1, C4]

layout(push_constant) uniform constBuffer {
    ivec4 outputSize;     // [W_out, H_out, C_out, N]
    // ... other fields (pad, stride etc.) may be unused in col2im
} uConstant;

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main() {
    uint gid = gl_GlobalInvocationID.x;

    int W_out = uConstant.outputSize.x;
    int H_out = uConstant.outputSize.y;
    int C_out = uConstant.outputSize.z;
    int N = uConstant.outputSize.w;
    int C4 = (C_out + 3) / 4;

    int total = C4 * W_out * H_out * N;
    if (gid >= uint(total)) return;

    int c4 = int(gid / (W_out * H_out * N));
    int pixel = int(gid % (W_out * H_out * N));

    int w = pixel % W_out;
    int h = (pixel / W_out) % H_out;
    int n = pixel / (W_out * H_out);

    vec4 color = texelFetch(uInput, ivec3(pixel, 0, c4), 0);
    vec4 bias  = texelFetch(uBias,  ivec3(0, 0, c4), 0);
    color += bias;

#ifdef RELU
    color = max(color, vec4(0));
#endif
#ifdef RELU6
    color = clamp(color, vec4(0), vec4(6));
#endif

    imageStore(uOutput, ivec3(w, n * H_out + h, c4), color);
}